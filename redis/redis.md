# Redis知识点

## redis和memcached的区别和共同点

共同点：

1. 基于内存的数据库，一般都用于缓存
2. 都有过期策略
3. 性能非常高

区别：

1. redis支持丰富的数据类型。memcached值支持简单的kv数据类型；
2. redis支持数据的持久化，memcached只支持将数据存在内存之中；
3. redis有灾难恢复机制；
4. redis在内存用完之后会将数据持久化到磁盘中，memcached在服务器内存使用完后会报异常；
5. redis原生支持cluster模式，memcached没有原生的集群模式；
6. redis是单线程的多路IO复用模型，memcached是多线程，非阻塞的IO复用网络模型；
7. redis支持发布订阅模型、Lua脚本、事务等功能；
8. redis同时使用惰性删除与定期删除，而memcached只用了惰性删除。

## 过期键删除策略

1. 定时删除: 在设置键过期时间的同时，创建定时器，让定时器在键过期时间来临时， 立即执行对键的删除操作

   > 优点 :对内存是最友好的 -> 使用定时器能保证过期键能尽快删除
   >
   > 缺点: 对CPU时间不优化 -> 当过期键较多，删除过期键可能会占用相当一部分的CPU时间， 会对服务器的响应时间和吞吐量造成影响

2. 惰性删除: 每次从键空间中获取键的时候，检查取得的键是否过期，如果过期就删除这个键，没有过期就返回

   > 优点: 对CPU时间最友好 -> 取出键时对键进行过期检查，保证删除过期键的操作只会在非做不可的情况下进行
   >
   > 缺点: 对内存不友好， 在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除

3. 定期删除: 每隔一段时间，程序就对数据库进行检查，删除过期键(以上两种的折中方法)

   > 通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响
   >
   > 有效地减少因为过期键带来的内存消费

### 缓存数据的处理流程

1. 用户请求的数据在缓存中就直接返回
2. 缓存中不存在的话就看db中是否存在
3. db存在的话就更新缓存中的数据
4. db不存在就会返回空数据

## AOF、RDB和复制功能对过期键的处理

### 生成RDB文件

> 执行<kbd>SAVE</kbd>或者<kbd>BGSAVE</kbd>创建一个新的RDB文件， 会对数据库中的键进行检查， 已经过期的键不会被保存先创建的RDB文件中

因此， 数据库中包含过期键不会对新生成的RDB文件造成影响

### 载入RDB文件

如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入

> 主服务器模式：对保存的键进行检查，未过期的载入到DB，过期则会忽略
>
> 从服务器模式：无论是否过期都会载入到DB，因此过期键对载入RDB文件的从服务器不会造成影响。

### AOF文件写入/重写

写入：以AOF持久化模式运行时，某个键已经过期但是没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生影响。

重写：过期键不会对AOF重写造成影响

> 如果使用GET message命令，试图访问过期的message键，将执行三个动作
>
> 1. 从数据库中删除message键
> 2. 追加一条DEL message命令到AOF文件
> 3. 向执行GET命令的客户端返回空回复

## redis常见的数据结构以及使用场景分析

### string

**介绍** ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 **简单动态字符串**（simple dynamic
string，**SDS**）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API
是安全的，不会造成缓冲区溢出。

**常用命令：** `set,get,strlen,exists,decr,incr,setex` 等等。

**应用场景：** 一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。

**普通字符串的基本操作：**

```shell
127.0.0.1:6379> set key value #设置 key-value 类型的值
OK
127.0.0.1:6379> get key # 根据 key 获得对应的 value
"value"
127.0.0.1:6379> exists key  # 判断某个 key 是否存在
(integer) 1
127.0.0.1:6379> strlen key # 返回 key 所储存的字符串值的长度。
(integer) 5
127.0.0.1:6379> del key # 删除某个 key 对应的值
(integer) 1
127.0.0.1:6379> get key
(nil)
```

### list

**介绍** ：**list** 即是 **链表**。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 **
LinkedList**，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 **双向链表**，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

**常用命令:** `rpush,lpop,lpush,rpop,lrange,llen` 等。

**应用场景:** 发布与订阅或者说消息队列、慢查询。

**通过<kbd>rpush/lpop</kbd>实现队列：**右进左出

```shell
127.0.0.1:6379> rpush myList value1 # 向 list 的头部（右边）添加元素
(integer) 1
127.0.0.1:6379> rpush myList value2 value3 # 向list的头部（最右边）添加多个元素
(integer) 3
127.0.0.1:6379> lpop myList # 将list的尾部(最左边)元素取出
"value1"
127.0.0.1:6379> lrange myList 0 1 # 查看对应下标的list列表， 0 为 start,1为 end
1) "value2"
2) "value3"
127.0.0.1:6379> lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一
1) "value2"
2) "value3"
```

**通过<kbd>rpush/rpop</kbd>实现栈**：右进右出

```shell
127.0.0.1:6379> rpush myList value1 value2 value3
(integer) 3
127.0.0.1:6379> lrange myList 0 1 # 查看对应下标的list列表， 0 为 start,1为 end
1) "value1"
2) "value2"
127.0.0.1:6379> lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一
1) "value1"
2) "value2"
3) "value3"
```

### hash

**介绍** ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，**
特别适合用于存储对象**，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。

**常用命令：** `hset,hmset,hexists,hget,hgetall,hkeys,hvals` 等。

**应用场景:** 系统中对象数据的存储。

### set

**介绍 ：** set 类似于 Java 中的 `HashSet` 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set
提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis
可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。

**常用命令：** `sadd,spop,smembers,sismember,scard,sinterstore,sunion` 等。

**应用场景:** 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景

### sorted set

**介绍：** 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和
TreeSet 的结合体。

**常用命令：** `zadd,zcard,zscore,zrange,zrevrange,zrem` 等。

**应用场景：** 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。

### bitmap

**介绍：** bitmap 存储的是连续的二进制数字（0 和 1），通过 bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以
bitmap 本身会极大的节省储存空间。

**常用命令：** `setbit` 、`getbit` 、`bitcount`、`bitop`

**应用场景：** 适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。

使用场景：

+ 用户分析行为

+ 统计活跃用户
+ 用户在线状态

## redis单线程模型详解

。。。。。待整理