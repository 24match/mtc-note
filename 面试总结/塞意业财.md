### 1. 说一下印象深刻的系统
### 2. 如何保证你的系统出入库不会出现负库存的现象

+ 悲观锁：即查询某条数据时，让数据库为该条记录加锁，锁住后无法操作

  > select for update

+ 乐观锁：在更新时判断此时库存是否是之前查询出来的库存，如果相同表示没人修改，可以更新库存，否则表示别人抢过资源，不进行库存操作。

  > 使用乐观锁需要修改数据库的事务隔离级别：Read commited

+ 分段执行的排队：

​		**将提交操作分成两段式** 

 1. 第一阶段进行申请，申请预减库存，申请成功后，进入消息队列；

    > 从db前移到redis中，所以的预减库存的操作都放在内存中，由于redis不存在锁所以不会出现互相等待，并且由于redis的写性能和读性能都比db要高，也就解决了高并发下的性能问题。

 2. 第二阶段进行确认，从消息队列中申请令牌，然后完成下单操作。查库存 ->  创建订单 -> 扣减库存。通过分布式锁来保障多个provider实例并发下单产生超卖的问题

    > 通过队列等异步手段，将变化的数据异步写入到db中
    >
    > 引入队列，按照次序更新到DB，串行处理，当达到库存阈值就不在消费队列，并且关闭接下来的功能，也就解决了超卖的问题

### 3. 加锁是怎么实现的
### 4. 你的系统金额是使用什么数据库字段类型的，oracle用什么，mssql用什么

在oracle使用number，mssql是money

### 5. 为什么不用float

### 6. 说一下java的线程池
### 7. 为什么实体类必须重写equals和hashcode
### 8. AOP的两种实现方式
### 9. 说一下CGLIB
### 10. 说一下对秒杀系统的设计
### 11. 你了解springboot吗？怎么写一个starter？
### 12. Spring Cloud Nacos和Eureka跟Consoul的区别
### 13. Nacos符合了CAP的什么原则
### 14. 说一下java的引用方式
### 15. redis的几种常用类型
### 16. 平时用redis来做什么
### 17. redis缓存击穿，缓存穿透的解决方案

+ 缓存雪崩：所有的key的失效时间都是12小时，中午12点刷新，但是0点的时候有一个什么活动的有大量的用户涌进来，假设当时每秒有6000个请求，缓存可以抗住每秒5000的请求，但是缓存当时的key都失效了，6000个请求全部打入到数据库中，dba就挂了，然后我们重启数据库，立马又被新的流量给打死 了，值就是我的理解的缓存血崩。

  > 批量往redis存数据的时候，把每个key的失效时间都设置一个随机值，保证数据不会在同一时间失效。或者设置热点数据缓存永不过期，有更新操作的时候刷新缓存。

+ 缓存穿透：指缓存和数据库中都没有数据，而用户不断发起请求

  > 在接口层新增校验，比如用户鉴权，参数做校验，不合法的直接就return掉，还有redis里面有**布隆过滤器**可以防止缓存穿透的发生，判断key是否在数据库中存在，不存在的话直接return，存在就插db刷新key value再return

+ 缓存击穿：缓存击穿是指一个key非常热点，在不断的扛着大并发，大并发集中对一个点进行访问，当这个key在失效的瞬间，持续大的并发就会击穿缓存，直接请求数据库

  > 设置热点数据永不过期或者加上互斥锁就可以搞定。

### 18. 索引失效的场景

### 19.Spring注入的实现方式

